use std::collections::HashMap;use k8s_openapi::api::core::v1::Namespace;use kube::{Api, Client};use kube::api::DeleteParams;use log::debug;use serde_json::Value;use tokio::runtime::Runtime;use crate::config::pg_config::PG;use crate::orm::common_mapper::{delete_all, select_flow_instances_deployed};const DATABASE_ERROR: &str = "数据库交互错误";const K8S_CONTACT_ERROR: &str = "k8s集群交互错误";pub(super) fn stop_instances(rt: &Runtime, _: &mut HashMap<&str, Value>) -> Result<(), &'static str> {    let delete_records = async {        let mut rb = PG.lock().await;        delete_all(&mut *rb, "flow_instance_deploys").await.map_err(|_|DATABASE_ERROR)    };    let get_records = async {        let mut rb = PG.lock().await;        select_flow_instances_deployed(&mut *rb).await.map_err(|e| {            debug!("{}", e);            DATABASE_ERROR        })    };    let remove_deploy = async {        let client = Client::try_default().await.map_err(|_|K8S_CONTACT_ERROR)?;        let ns_api: Api<Namespace> = Api::all(client);        let params: DeleteParams = Default::default();        let instances = get_records.await?;        for instance in instances {            let id = instance.get("id").unwrap();            let ns_name = format!("workflow-{}", id.get(..6).unwrap());            ns_api.delete(&ns_name, &params).await;        }        Ok::<(), &str>(())    };    rt.block_on(remove_deploy)?;    rt.block_on(delete_records)?;    Ok(())}